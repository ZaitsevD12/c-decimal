# c_decimal

Простая библиотека на C для работы с decimal-числами высокой точности. Диапазон ±79 228 162 514 264 337 593 543 950 335, до 28 знаков после запятой. Главное преимущество — нет ошибок округления, которые обычно бывают с float/double, поэтому подходит для финансовых расчётов и всего, где нужна точность.

Особенности проекта: тип s21_decimal на четырёх int'ах (96 бит мантисса, знак и масштаб). Никакого __int128, всё вручную.

### Что внутри
- Арифметика: сложение, вычитание, умножение, деление (с банковским округлением, когда не влезает).
- Сравнения: меньше, больше, равно и все их вариации.
- Округления: floor, round, truncate, negate.
- Конвертации из/в int и float (с обработкой значимых цифр и ошибок).

Функции возвращают код ошибки: 0 — всё ок, 1/2 — переполнение, 3 — деление на ноль.

### Сборка и тесты
Всё через Makefile:
- `make` — собирает статическую библиотеку s21_decimal.a
- `make test` — собирает и запускает тесты на Check
- `make gcov_report` — отчет по покрытию (html, открывается в браузере)
- `make clean` — убирает мусор

Тестов много, больше трёх сотен кейсов. Проверяют обычные случаи, граничные значения, разные масштабы, отрицательные числа, переполнения. Покрытие по каждой функции выше 80%, как и требовалось. При запуске тестов всё выводится подробно: входные данные, ожидаемый результат, что получилось на самом деле, плюс побитовое сравнение.

Код написан по Google Style, чистый C11, без legacy-фич.

### Как пользоваться
Подключаешь s21_decimal.h и линкуешь библиотеку.

Пример:
```c
#include "s21_decimal.h"

int main() {
    s21_decimal a = {{15, 0, 0, 0}};      // 15
    s21_decimal b = {{7, 0, 0, 0}};       // 7
    s21_decimal result;
    s21_add(a, b, &result);              // result = 22
    return 0;
}
